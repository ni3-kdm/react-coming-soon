{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.FlipClock = factory();\n})(this, function () {\n  'use strict';\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function _typeof(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n  /**\n   * These are a collection of helper functions, some borrowed from Lodash,\n   * Underscore, etc, to provide common functionality without the need for using\n   * a dependency. All of this is an attempt to reduce the file size of the\n   * library.\n   *\n   * @namespace Helpers.Functions\n   */\n\n  /**\n   * Throw a string as an Error exception.\n   *\n   * @function error\n   * @param  {string} string - The error message.\n   * @return {void}\n   * @memberof Helpers.Functions\n   */\n\n\n  function error(string) {\n    throw Error(string);\n  }\n  /**\n   * Check if `fn` is a function, and call it with `this` context and pass the\n   * arguments.\n   *\n   * @function callback\n   * @param  {string} string - The callback fn.\n   * @param  {...*} args - The arguments to pass.\n   * @return {void}\n   * @memberof Helpers.Functions\n   */\n\n\n  function callback(fn) {\n    if (isFunction(fn)) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return fn.call.apply(fn, [this].concat(args));\n    }\n  }\n  /**\n   * Round the value to the correct value. Takes into account negative numbers.\n   *\n   * @function round\n   * @param  {value} string - The value to round.\n   * @return {string} - The rounded value.\n   * @memberof Helpers.Functions\n   */\n\n\n  function round(value) {\n    return isNegativeZero(value = isNegative(value) ? Math.ceil(value) : Math.floor(value)) ? ('-' + value).toString() : value;\n  }\n  /**\n   * Returns `true` if `undefined or `null`.\n   *\n   * @function noop\n   * @param  {value} string - The value to check.\n   * @return {boolean} - `true` if `undefined or `null`.\n   * @memberof Helpers.Functions\n   */\n\n\n  function noop(value) {\n    return !isUndefined(value) && !isNull(value);\n  }\n  /**\n   * Returns a function that executes the `before` attribute and passes that value\n   * to `after` and the subsequent value is returned.\n   *\n   * @function chain\n   * @param  {function} before - The first function to execute.\n   * @param  {function} after - The subsequent function to execute.\n   * @return {function} - A function that executes the chain.\n   * @memberof Helpers.Functions\n   */\n\n\n  function chain(before, after) {\n    return function () {\n      return after(before());\n    };\n  }\n  /**\n   * Returns a function that returns maps the values before concatenating them.\n   *\n   * @function concatMap\n   * @param  {function} fn - The map callback function.\n   * @return {function} - A function that executes the map and concatenation.\n   * @memberof Helpers.Functions\n   */\n\n\n  function concatMap(fn) {\n    return function (x) {\n      return x.map(fn).reduce(function (x, y) {\n        return x.concat(y);\n      }, []);\n    };\n  }\n  /**\n   * Flatten an array.\n   *\n   * @function flatten\n   * @param  {array} value - The array to flatten.\n   * @return {array} - The flattened array.\n   * @memberof Helpers.Functions\n   */\n\n\n  function flatten(value) {\n    return concatMap(function (value) {\n      return value;\n    })(value);\n  }\n  /**\n   * Deep flatten an array.\n   *\n   * @function deepFlatten\n   * @param  {array} value - The array to flatten.\n   * @return {array} - The flattened array.\n   * @memberof Helpers.Functions\n   */\n\n\n  function deepFlatten(x) {\n    return concatMap(function (x) {\n      return Array.isArray(x) ? deepFlatten(x) : x;\n    })(x);\n  }\n  /**\n   * Returns the length of a deep flatten array.\n   *\n   * @function length\n   * @param  {array} value - The array to count.\n   * @return {number} - The length of the deep flattened array.\n   * @memberof Helpers.Functions\n   */\n\n\n  function length(value) {\n    return deepFlatten(value).length;\n  }\n  /**\n   * Determines if a value is a negative zero.\n   *\n   * @function isNegativeZero\n   * @param  {number} value - The value to check.\n   * @return {boolean} - Returns `true` if the value is a negative zero (`-0`).\n   * @memberof Helpers.Functions\n   */\n\n\n  function isNegativeZero(value) {\n    return 1 / Math.round(value) === -Infinity;\n  }\n  /**\n   * Determines if a value is a negative.\n   *\n   * @function isNegative\n   * @param  {number} value - The value to check.\n   * @return {boolean} - Returns `true` if the value is a negative.\n   * @memberof Helpers.Functions\n   */\n\n\n  function isNegative(value) {\n    return isNegativeZero(value) || value < 0;\n  }\n  /**\n   * Determines if a value is `null`.\n   *\n   * @function isNull\n   * @param  {*} value - The value to check.\n   * @return {boolean} - Returns `true` if the value is a `null`.\n   * @memberof Helpers.Functions\n   */\n\n\n  function isNull(value) {\n    return value === null; // || typeof value === 'null';\n  }\n  /**\n   * Determines if a value is `undefined`.\n   *\n   * @function isNull\n   * @param  {*} value - The value to check.\n   * @return {boolean} - Returns `true` if the value is a `undefined`.\n   * @memberof Helpers.Functions\n   */\n\n\n  function isUndefined(value) {\n    return typeof value === 'undefined';\n  }\n  /**\n   * Determines if a value is a constructor.\n   *\n   * @function isConstructor\n   * @param  {*} value - The value to check.\n   * @return {boolean} - Returns `true` if the value is a constructor.\n   * @memberof Helpers.Functions\n   */\n\n\n  function isConstructor(value) {\n    return value instanceof Function && !!value.name;\n  }\n  /**\n   * Determines if a value is a string.\n   *\n   * @function isString\n   * @param  {*} value - The value to check.\n   * @return {boolean} - Returns `true` if the value is a string.\n   * @memberof Helpers.Functions\n   */\n\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  /**\n   * Determines if a value is a array.\n   *\n   * @function isString\n   * @param  {*} value - The value to check.\n   * @return {boolean} - Returns `true` if the value is a string.\n   * @memberof Helpers.Functions\n   */\n\n\n  function isArray(value) {\n    return value instanceof Array;\n  }\n  /**\n   * Determines if a value is an object.\n   *\n   * @function isObject\n   * @param  {*} value - The value to check.\n   * @return {boolean} - Returns `true` if the value is an object.\n   * @memberof Helpers.Functions\n   */\n\n\n  function isObject(value) {\n    var type = _typeof(value);\n\n    return value != null && !isArray(value) && (type == 'object' || type == 'function');\n  }\n  /**\n   * Determines if a value is a function.\n   *\n   * @function isObject\n   * @param  {*} value - The value to check.\n   * @return {boolean} - Returns `true` if the value is a function.\n   * @memberof Helpers.Functions\n   */\n\n\n  function isFunction(value) {\n    return value instanceof Function;\n  }\n  /**\n   * Determines if a value is a number.\n   *\n   * @function isObject\n   * @param  {*} value - The value to check.\n   * @return {boolean} - Returns `true` if the value is a number.\n   * @memberof Helpers.Functions\n   */\n\n\n  function isNumber(value) {\n    return !isNaN(value);\n  }\n  /**\n   * Converts a string into kebab case.\n   *\n   * @function kebabCase\n   * @param  {string} string - The string to convert.\n   * @return {string} - The converted string.\n   * @memberof Helpers.Functions\n   */\n\n\n  function kebabCase(string) {\n    return string.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/\\s+/g, '-').toLowerCase();\n  }\n\n  var Component =\n  /*#__PURE__*/\n  function () {\n    /**\n     * Abstract base class.\n     *\n     * @class Component\n     * @param {(object|undefined)} [attributes] - The instance attributes.\n     */\n    function Component(attributes) {\n      _classCallCheck(this, Component);\n\n      this.setAttribute(Object.assign({\n        events: {}\n      }, attributes));\n    }\n    /**\n     * Get the `name` attribute.\n     *\n     * @type {string}\n     */\n\n\n    _createClass(Component, [{\n      key: \"emit\",\n\n      /**\n       * Emit an event.\n       *\n       * @param  {string} key - The event id/key.\n       * @return {Component} - Returns `this` instance.\n       */\n      value: function emit(key) {\n        var _this = this;\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        if (this.events[key]) {\n          this.events[key].forEach(function (event) {\n            event.apply(_this, args);\n          });\n        }\n\n        return this;\n      }\n      /**\n       * Start listening to an event.\n       *\n       * @param  {string} key - The event id/key.\n       * @param  {Function} fn - The listener callback function.\n       * @param  {boolean} [once=false] - Should the event handler be fired a\n       *     single time.\n       * @return {Component} - Returns `this` instance.\n       */\n\n    }, {\n      key: \"on\",\n      value: function on(key, fn) {\n        if (!this.events[key]) {\n          this.events[key] = [];\n        }\n\n        this.events[key].push(fn);\n        return this;\n      }\n      /**\n       * Stop listening to an event.\n       *\n       * @param {string} key - The event id/key.\n       * @param {(Function|undefined)} fn - The listener callback function. If no\n       *     function is defined, all events with the specified id/key will be\n       *     removed. Otherwise, only the event listeners matching the id/key AND\n       *     callback will be removed.\n       * @return {Component} - Returns `this` instance.\n       */\n\n    }, {\n      key: \"off\",\n      value: function off(key, fn) {\n        if (this.events[key] && fn) {\n          this.events[key] = this.events[key].filter(function (event) {\n            return event !== fn;\n          });\n        } else {\n          this.events[key] = [];\n        }\n\n        return this;\n      }\n      /**\n       * Listen to an event only one time.\n       *\n       * @param  {string} key - The event id/key.\n       * @param  {Function} fn - The listener callback function.\n       * @return {Component} - Returns `this` instance.\n       */\n\n    }, {\n      key: \"once\",\n      value: function once(key, fn) {\n        var _this2 = this;\n\n        fn = chain(fn, function () {\n          return _this2.off(key, fn);\n        });\n        return this.on(key, fn, true);\n      }\n      /**\n       * Get an attribute. Returns null if no attribute is defined.\n       *\n       * @param  {string} key - The attribute name.\n       * @return {*} - The attribute value.\n       */\n\n    }, {\n      key: \"getAttribute\",\n      value: function getAttribute(key) {\n        return this.hasOwnProperty(key) ? this[key] : null;\n      }\n      /**\n       * Get all the atttributes for this instance.\n       *\n       * @return {object} - The attribute dictionary.\n       */\n\n    }, {\n      key: \"getAttributes\",\n      value: function getAttributes() {\n        var _this3 = this;\n\n        var attributes = {};\n        Object.getOwnPropertyNames(this).forEach(function (key) {\n          attributes[key] = _this3.getAttribute(key);\n        });\n        return attributes;\n      }\n      /**\n       * Get only public the atttributes for this instance. Omits any attribute\n       * that starts with `$`, which is used internally.\n       *\n       * @return {object} - The attribute dictionary.\n       */\n\n    }, {\n      key: \"getPublicAttributes\",\n      value: function getPublicAttributes() {\n        var _this4 = this;\n\n        return Object.keys(this.getAttributes()).filter(function (key) {\n          return !key.match(/^\\$/);\n        }).reduce(function (obj, key) {\n          obj[key] = _this4.getAttribute(key);\n          return obj;\n        }, {});\n      }\n      /**\n       * Set an attribute key and value.\n       *\n       * @param  {string} key - The attribute name.\n       * @param  {*} value - The attribute value.\n       * @return {void}\n       */\n\n    }, {\n      key: \"setAttribute\",\n      value: function setAttribute(key, value) {\n        if (isObject(key)) {\n          this.setAttributes(key);\n        } else {\n          this[key] = value;\n        }\n      }\n      /**\n       * Set an attributes by object of key/value pairs.\n       *\n       * @param  {object} values - The object dictionary.\n       * @return {void}\n       */\n\n    }, {\n      key: \"setAttributes\",\n      value: function setAttributes(values) {\n        for (var i in values) {\n          this.setAttribute(i, values[i]);\n        }\n      }\n      /**\n       * Helper method to execute the `callback()` function.\n       *\n       * @param  {Function} fn - The callback function.\n       * @return {*} - Returns the executed callback function.\n       */\n\n    }, {\n      key: \"callback\",\n      value: function callback$$1(fn) {\n        return callback.call(this, fn);\n      }\n      /**\n       * Factor method to static instantiate new instances. Useful for writing\n       * clean expressive syntax with chained methods.\n       *\n       * @param  {...*} args - The callback arguments.\n       * @return {*} - The new component instance.\n       */\n\n    }, {\n      key: \"name\",\n      get: function get() {\n        if (!(this.constructor.defineName instanceof Function)) {\n          error('Every class must define its name.');\n        }\n\n        return this.constructor.defineName();\n      }\n      /**\n       * The `events` attribute.\n       *\n       * @type {object}\n       */\n\n    }, {\n      key: \"events\",\n      get: function get() {\n        return this.$events || {};\n      },\n      set: function set(value) {\n        this.$events = value;\n      }\n    }], [{\n      key: \"make\",\n      value: function make() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return _construct(this, args);\n      }\n    }]);\n\n    return Component;\n  }();\n  /**\n   * @namespace Helpers.Digitize\n   */\n\n  /**\n   * Digitize a number, string, or an array into a digitized array. This function\n   * use by the `Face`, which convert the digitized array into an array of `List`\n   * instances.\n   *\n   * @function digitize\n   * @param  {*} value - The value to digitize.\n   * @param  {(Object|undefined)} [options] - The digitizer options.\n   * @return {array} - The digitized array.\n   * @memberof Helpers.Digitize\n   */\n\n\n  function digitize(value, options) {\n    options = Object.assign({\n      minimumDigits: 0,\n      prependLeadingZero: true\n    }, options);\n\n    function prepend(number) {\n      var shouldPrependZero = options.prependLeadingZero && number.toString().split('').length === 1;\n      return (shouldPrependZero ? '0' : '').concat(number);\n    }\n\n    function digits(arr, min) {\n      var length$$1 = deepFlatten(arr).length;\n\n      if (length$$1 < min) {\n        for (var i = 0; i < min - length$$1; i++) {\n          arr[0].unshift('0');\n        }\n      }\n\n      return arr;\n    }\n\n    return digits(flatten([value]).map(function (number) {\n      return flatten(deepFlatten([number]).map(function (number) {\n        return prepend(number).split('');\n      }));\n    }), options.minimumDigits || 0);\n  }\n  /**\n   * @namespace Helpers.Value\n   */\n\n  /**\n   * An array of objects with min/max ranges.\n   *\n   * @private\n   * @type {array}\n   */\n\n\n  var RANGES = [{\n    // 0-9\n    min: 48,\n    max: 57\n  }, {\n    // a-z\n    min: 65,\n    max: 90\n  }, {\n    // A-Z\n    min: 97,\n    max: 122\n  }];\n  /**\n   * Format a string into a new data type. Currently only supports string to\n   * number conversion.\n   *\n   * @private\n   * @function format\n   * @param {string} string - The string to format.\n   * @param {string} type - The data type (represented as a string) used to\n   *     convert the string.\n   * @return {boolean} - Returns the formatted string.\n   */\n\n  function format(string, type) {\n    switch (type) {\n      case 'number':\n        return parseFloat(string);\n    }\n\n    return string;\n  }\n  /**\n   * Find the range object from the `RANGES` constant from the character given.\n   * This is mainly an interval method, but can be used by faces to help\n   * determine what the next value of a string should be.\n   *\n   * @private\n   * @function format\n   * @param {string} char - The char used to determine the range.\n   * @param {string} type - The data type (represented as a string) used to\n   *     convert the string.\n   * @return {boolean} - Returns the formatted string.\n   */\n\n\n  function findRange(_char) {\n    for (var i in RANGES) {\n      var code = _char.toString().charCodeAt(0);\n\n      if (RANGES[i].min <= code && RANGES[i].max >= code) {\n        return RANGES[i];\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Create a string from a character code, which is returned by the callback.\n   *\n   * @private\n   * @callback stringFromCharCodeBy\n   * @param {string} char - The char used to determine the range.\n   * @param {function} fn - The callback function receives `range` and `code`\n   *     arguments. This function should return a character code.\n   * @return {string} - Creates a string from the character code returned by the\n   *     callback function.\n   */\n\n\n  function stringFromCharCodeBy(_char2, fn) {\n    return String.fromCharCode(fn(findRange(_char2), _char2.charCodeAt(0)));\n  }\n  /**\n   * Calculate the next value for a string. 'a' becomes 'b'. 'A' becomes 'B'. 1\n   * becomes 2, etc. If multiple character strings are passed, 'aa' would become\n   * 'bb'.\n   *\n   * @function next\n   * @param  {(string|number)} value - The string or number to convert.\n   * @return {string} - The formatted string\n   * @memberof Helpers.Value\n   */\n\n\n  function next(value) {\n    var converted = value.toString().split('').map(function (_char3) {\n      return stringFromCharCodeBy(_char3, function (range, code) {\n        return !range || code < range.max ? code + 1 : range.min;\n      });\n    }).join('');\n    return format(converted, _typeof(value));\n  }\n  /**\n   * Calculate the prev value for a string. 'b' becomes 'a'. 'B' becomes 'A'. 2\n   * becomes 1, 0 becomes 9, etc. If multiple character strings are passed, 'bb'\n   * would become 'aa'.\n   *\n   * @function prev\n   * @param  {(string|number)} value - The string or number to convert.\n   * @return {string} - The formatted string\n   * @memberof Helpers.Value\n   */\n\n\n  function prev(value) {\n    var converted = value.toString().split('').map(function (_char4) {\n      return stringFromCharCodeBy(_char4, function (range, code) {\n        return !range || code > range.min ? code - 1 : range.max;\n      });\n    }).join('');\n    return format(converted, _typeof(value));\n  }\n\n  var FaceValue =\n  /*#__PURE__*/\n  function (_Component) {\n    _inherits(FaceValue, _Component);\n    /**\n     * The `FaceValue` class handles all the digitizing for the `Face`.\n     *\n     * @class FaceValue\n     * @extends Component\n     * @param {*} value - The `FaceValue`'s actual value. Most likely should\n     *     string, number, or Date. But since the Face handles the value, it\n     *     could be anything.\n     * @param {(object|undefined)} [attributes] - The instance attributes.\n     */\n\n\n    function FaceValue(value, attributes) {\n      var _this;\n\n      _classCallCheck(this, FaceValue);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(FaceValue).call(this, Object.assign({\n        format: function format(value) {\n          return value;\n        },\n        prependLeadingZero: true,\n        minimumDigits: 0\n      }, attributes)));\n\n      if (!_this.value) {\n        _this.value = value;\n      }\n\n      return _this;\n    }\n    /**\n     * The `digits` attribute.\n     *\n     * @type {(Array|undefined)}\n     */\n\n\n    _createClass(FaceValue, [{\n      key: \"isNaN\",\n\n      /**\n       * Returns `true` if the `value` attribute is not a number.\n       *\n       * @return {boolean} - `true` is the value is not a number.\n       */\n      value: function (_isNaN) {\n        function isNaN() {\n          return _isNaN.apply(this, arguments);\n        }\n\n        isNaN.toString = function () {\n          return _isNaN.toString();\n        };\n\n        return isNaN;\n      }(function () {\n        return isNaN(this.value);\n      })\n      /**\n       * Returns `true` if the `value` attribute is a number.\n       *\n       * @return {boolean} - `true` is the value is a number.\n       */\n\n    }, {\n      key: \"isNumber\",\n      value: function isNumber$$1() {\n        return isNumber();\n      }\n      /**\n       * Clones the current `FaceValue` instance, but sets a new value to the\n       * cloned instance. Used for copying the current instance options and\n       * methods, but setting a new value.\n       *\n       * @param  {*} value - The n\n       * @param {(object|undefined)} [attributes] - The instance attributes.\n       * @return {FaceValue} - The cloned `FaceValue`.\n       */\n\n    }, {\n      key: \"clone\",\n      value: function clone(value, attributes) {\n        return new this.constructor(value, Object.assign(this.getPublicAttributes(), attributes));\n      }\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n\n    }, {\n      key: \"digits\",\n      get: function get() {\n        return this.$digits;\n      },\n      set: function set(value) {\n        this.$digits = value;\n        this.minimumDigits = Math.max(this.minimumDigits, length(value));\n      }\n      /**\n       * The `value` attribute.\n       *\n       * @type {*}\n       */\n\n    }, {\n      key: \"value\",\n      get: function get() {\n        return this.$value;\n      },\n      set: function set(value) {\n        this.$value = value;\n        this.digits = digitize(this.format(value), {\n          minimumDigits: this.minimumDigits,\n          prependLeadingZero: this.prependLeadingZero\n        });\n      }\n    }], [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'FaceValue';\n      }\n    }]);\n\n    return FaceValue;\n  }(Component);\n  /**\n   * Validate the data type of a variable.\n   *\n   * @function validate\n   * @param {*} value - The value to validate.\n   * @param {...*} args - The data types to use for validate.\n   * @return {boolean} - Returns `true`is the value has a valid data type.\n   * @memberof Helpers.Validate\n   */\n\n\n  function validate(value) {\n    var success = false;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    flatten(args).forEach(function (arg) {\n      if (isNull(value) && isNull(arg) || isObject(arg) && value instanceof arg || isFunction(arg) && !isConstructor(arg) && arg(value) === true || isString(arg) && _typeof(value) === arg) {\n        success = true;\n      }\n    });\n    return success;\n  }\n  /**\n   * @alias ConsoleMessages\n   * @type {object}\n   * @memberof module:Config/ConsoleMessages\n   */\n\n\n  var ConsoleMessages = {\n    className: 'The className() is not defined.',\n    items: 'The items property must be an array.',\n    theme: 'The theme property must be an object.',\n    language: 'The language must be an object.',\n    date: 'The value must be an instance of a Date.',\n    face: 'The face must be an instance of a Face class.',\n    element: 'The element must be an instance of an HTMLElement',\n    faceValue: 'The face must be an instance of a FaceValue class.',\n    timer: 'The timer property must be an instance of a Timer class.'\n  };\n\n  var Face =\n  /*#__PURE__*/\n  function (_Component) {\n    _inherits(Face, _Component);\n    /**\n     * This class is meant to be provide an interface for all other faces to\n     * extend.\n     *\n     * @class Face\n     * @extends Component\n     * @param {(FaceValue|object)} value - The `Face` value. If not an instance\n     *     of FaceValue, this argument is assumed to be the instance attributes.\n     * @param {(object|undefined)} [attributes] - The instance attributes.\n     */\n\n\n    function Face(value, attributes) {\n      var _this;\n\n      _classCallCheck(this, Face);\n\n      if (!(value instanceof FaceValue) && isObject(value)) {\n        attributes = value;\n        value = undefined;\n      }\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Face).call(this));\n\n      _this.setAttributes(Object.assign({\n        autoStart: true,\n        countdown: false,\n        animationRate: 500\n      }, _this.defaultAttributes(), attributes || {}));\n\n      if (isNull(value) || isUndefined(value)) {\n        value = _this.defaultValue();\n      }\n\n      if (value) {\n        _this.value = value;\n      }\n\n      return _this;\n    }\n    /**\n     * The `dataType` attribute.\n     *\n     * @type {*}\n     */\n\n\n    _createClass(Face, [{\n      key: \"interval\",\n\n      /**\n       * This method is called with every interval, or every time the clock\n       * should change, and handles the actual incrementing and decrementing the\n       * clock's `FaceValue`.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @param  {Function} fn - The interval callback.\n       * @return {Face} - This `Face` instance.\n       */\n      value: function interval(instance, fn) {\n        if (this.countdown) {\n          this.decrement(instance);\n        } else {\n          this.increment(instance);\n        }\n\n        callback.call(this, fn);\n\n        if (this.shouldStop(instance)) {\n          instance.stop();\n        }\n\n        return this.emit('interval');\n      }\n      /**\n       * Determines if the clock should stop or not.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @return {boolean} - Returns `true` if the clock should stop.\n       */\n\n    }, {\n      key: \"shouldStop\",\n      value: function shouldStop(instance) {\n        return !isUndefined(this.stopAt) ? this.stopAt === instance.value.value : false;\n      }\n      /**\n       * By default this just returns the value unformatted.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @param  {*} value - The value to format.\n       * @return {*} - The formatted value.\n       */\n\n    }, {\n      key: \"format\",\n      value: function format(instance, value) {\n        return value;\n      }\n      /**\n       * The default value for the `Face`.\n       *\n       * @return {*} - The default value.\n       */\n\n    }, {\n      key: \"defaultValue\",\n      value: function defaultValue() {} //\n\n      /**\n       * The default attributes for the `Face`.\n       *\n       * @return {(Object|undefined)} - The default attributes.\n       */\n\n    }, {\n      key: \"defaultAttributes\",\n      value: function defaultAttributes() {} //\n\n      /**\n       * The default data type for the `Face` value.\n       *\n       * @return {(Object|undefined)} - The default data type.\n       */\n\n    }, {\n      key: \"defaultDataType\",\n      value: function defaultDataType() {} //\n\n      /**\n       * Increment the clock.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @param  {Number} [amount] - The amount to increment. If the amount is not\n       *     defined, it is left up to the `Face` to determine the default value.\n       * @return {void}\n       */\n\n    }, {\n      key: \"increment\",\n      value: function increment(instance, amount) {} //\n\n      /**\n       * Decrement the clock.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @param  {Number} [amount] - The amount to decrement. If the amount is not\n       *     defined, it is left up to the `Face` to determine the default value.\n       * @return {void}\n       */\n\n    }, {\n      key: \"decrement\",\n      value: function decrement(instance, amount) {} //\n\n      /**\n       * This method is called right after clock has started.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @return {void}\n       */\n\n    }, {\n      key: \"started\",\n      value: function started(instance) {} //\n\n      /**\n       * This method is called right after clock has stopped.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @return {void}\n       */\n\n    }, {\n      key: \"stopped\",\n      value: function stopped(instance) {} //\n\n      /**\n       * This method is called right after clock has reset.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @return {void}\n       */\n\n    }, {\n      key: \"reset\",\n      value: function reset(instance) {} //\n\n      /**\n       * This method is called right after `Face` has initialized.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @return {void}\n       */\n\n    }, {\n      key: \"initialized\",\n      value: function initialized(instance) {} //\n\n      /**\n       * This method is called right after `Face` has rendered.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @return {void}\n       */\n\n    }, {\n      key: \"rendered\",\n      value: function rendered(instance) {} //\n\n      /**\n       * This method is called right after `Face` has mounted.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @return {void}\n       */\n\n    }, {\n      key: \"mounted\",\n      value: function mounted(instance) {\n        if (this.autoStart && instance.timer.isStopped) {\n          window.requestAnimationFrame(function () {\n            return instance.start(instance);\n          });\n        }\n      }\n      /**\n       * Helper method to instantiate a new `FaceValue`.\n       *\n       * @param  {FlipClock} instance - The `FlipClock` instance.\n       * @param  {object|undefined} [attributes] - The attributes passed to the\n       *     `FaceValue` instance.\n       * @return {Divider} - The instantiated `FaceValue`.\n       */\n\n    }, {\n      key: \"createFaceValue\",\n      value: function createFaceValue(instance, value) {\n        var _this2 = this;\n\n        return FaceValue.make(isFunction(value) && !value.name ? value() : value, {\n          minimumDigits: this.minimumDigits,\n          format: function format(value) {\n            return _this2.format(instance, value);\n          }\n        });\n      }\n    }, {\n      key: \"dataType\",\n      get: function get() {\n        return this.defaultDataType();\n      }\n      /**\n       * The `value` attribute.\n       *\n       * @type {*}\n       */\n\n    }, {\n      key: \"value\",\n      get: function get() {\n        return this.$value;\n      },\n      set: function set(value) {\n        if (!(value instanceof FaceValue)) {\n          value = this.createFaceValue(value);\n        }\n\n        this.$value = value;\n      }\n      /**\n       * The `stopAt` attribute.\n       *\n       * @type {*}\n       */\n\n    }, {\n      key: \"stopAt\",\n      get: function get() {\n        return this.$stopAt;\n      },\n      set: function set(value) {\n        this.$stopAt = value;\n      }\n      /**\n       * The `originalValue` attribute.\n       *\n       * @type {*}\n       */\n\n    }, {\n      key: \"originalValue\",\n      get: function get() {\n        return this.$originalValue;\n      },\n      set: function set(value) {\n        this.$originalValue = value;\n      }\n    }]);\n\n    return Face;\n  }(Component);\n  /**\n   * @classdesc Arabic Language Pack\n   * @desc This class will be used to translate tokens into the Arabic language.\n   * @namespace Languages.Arabic\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Arabic\n   */\n\n\n  var dictionary = {\n    'years': 'سنوات',\n    'months': 'شهور',\n    'days': 'أيام',\n    'hours': 'ساعات',\n    'minutes': 'دقائق',\n    'seconds': 'ثواني'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Arabic\n   */\n\n  var aliases = ['ar', 'ar-ar', 'arabic'];\n  var arAr =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary,\n    aliases: aliases\n  });\n  /**\n   * @classdesc Catalan Language Pack\n   * @desc This class will used to translate tokens into the Catalan language.\n   * @namespace Languages.Catalan\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Catalan\n   */\n\n  var dictionary$1 = {\n    'years': 'Anys',\n    'months': 'Mesos',\n    'days': 'Dies',\n    'hours': 'Hores',\n    'minutes': 'Minuts',\n    'seconds': 'Segons'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Catalan\n   */\n\n  var aliases$1 = ['ca', 'ca-es', 'catalan'];\n  var caEs =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$1,\n    aliases: aliases$1\n  });\n  /**\n   * @classdesc Czech Language Pack\n   * @desc This class will used to translate tokens into the Czech language.\n   * @namespace Languages.Czech\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Czech\n   */\n\n  var dictionary$2 = {\n    'years': 'Roky',\n    'months': 'Měsíce',\n    'days': 'Dny',\n    'hours': 'Hodiny',\n    'minutes': 'Minuty',\n    'seconds': 'Sekundy'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Czech\n   */\n\n  var aliases$2 = ['cs', 'cs-cz', 'cz', 'cz-cs', 'czech'];\n  var csCz =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$2,\n    aliases: aliases$2\n  });\n  /**\n   * @classdesc Danish Language Pack\n   * @desc This class will used to translate tokens into the Danish language.\n   * @namespace Languages.Danish\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Danish\n   */\n\n  var dictionary$3 = {\n    'years': 'År',\n    'months': 'Måneder',\n    'days': 'Dage',\n    'hours': 'Timer',\n    'minutes': 'Minutter',\n    'seconds': 'Sekunder'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Danish\n   */\n\n  var aliases$3 = ['da', 'da-dk', 'danish'];\n  var daDk =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$3,\n    aliases: aliases$3\n  });\n  /**\n   * @classdesc German Language Pack\n   * @desc This class will used to translate tokens into the German language.\n   * @namespace Languages.German\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.German\n   */\n\n  var dictionary$4 = {\n    'years': 'Jahre',\n    'months': 'Monate',\n    'days': 'Tage',\n    'hours': 'Stunden',\n    'minutes': 'Minuten',\n    'seconds': 'Sekunden'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.German\n   */\n\n  var aliases$4 = ['de', 'de-de', 'german'];\n  var deDe =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$4,\n    aliases: aliases$4\n  });\n  /**\n   * @classdesc English Language Pack\n   * @desc This class will used to translate tokens into the English language.\n   * @namespace Languages.English\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.English\n   */\n\n  var dictionary$5 = {\n    'years': 'Years',\n    'months': 'Months',\n    'days': 'Days',\n    'hours': 'Hours',\n    'minutes': 'Minutes',\n    'seconds': 'Seconds'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.English\n   */\n\n  var aliases$5 = ['en', 'en-us', 'english'];\n  var English =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$5,\n    aliases: aliases$5\n  });\n  /**\n   * @classdesc Spanish Language Pack\n   * @desc This class will used to translate tokens into the Spanish language.\n   * @namespace Languages.Spanish\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Spanish\n   */\n\n  var dictionary$6 = {\n    'years': 'Años',\n    'months': 'Meses',\n    'days': 'Días',\n    'hours': 'Horas',\n    'minutes': 'Minutos',\n    'seconds': 'Segundos'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Spanish\n   */\n\n  var aliases$6 = ['es', 'es-es', 'spanish'];\n  var esEs =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$6,\n    aliases: aliases$6\n  });\n  /**\n   * @classdesc Persian Language Pack\n   * @desc This class will used to translate tokens into the Persian language.\n   * @namespace Languages.Persian\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Persian\n   */\n\n  var dictionary$7 = {\n    'years': 'سال',\n    'months': 'ماه',\n    'days': 'روز',\n    'hours': 'ساعت',\n    'minutes': 'دقیقه',\n    'seconds': 'ثانیه'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Persian\n   */\n\n  var aliases$7 = ['fa', 'fa-ir', 'persian'];\n  var faIr =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$7,\n    aliases: aliases$7\n  });\n  /**\n   * @classdesc Finnish Language Pack\n   * @desc This class will used to translate tokens into the Finnish language.\n   * @namespace Languages.Finnish\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Finnish\n   */\n\n  var dictionary$8 = {\n    'years': 'Vuotta',\n    'months': 'Kuukautta',\n    'days': 'Päivää',\n    'hours': 'Tuntia',\n    'minutes': 'Minuuttia',\n    'seconds': 'Sekuntia'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Finnish\n   */\n\n  var aliases$8 = ['fi', 'fi-fi', 'finnish'];\n  var fiFi =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$8,\n    aliases: aliases$8\n  });\n  /**\n   * @classdesc Canadian French Language Pack\n   * @desc This class will used to translate tokens into the Canadian French language.\n   * @namespace Languages.CanadianFrench\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.CanadianFrench\n   */\n\n  var dictionary$9 = {\n    'years': 'Ans',\n    'months': 'Mois',\n    'days': 'Jours',\n    'hours': 'Heures',\n    'minutes': 'Minutes',\n    'seconds': 'Secondes'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.CanadianFrench\n   */\n\n  var aliases$9 = ['fr', 'fr-ca', 'french'];\n  var frCa =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$9,\n    aliases: aliases$9\n  });\n  /**\n   * @classdesc Hebrew Language Pack\n   * @desc This class will used to translate tokens into the Hebrew language.\n   * @namespace Languages.Hebrew\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Hebrew\n   */\n\n  var dictionary$10 = {\n    'years': 'שנים',\n    'months': 'חודש',\n    'days': 'ימים',\n    'hours': 'שעות',\n    'minutes': 'דקות',\n    'seconds': 'שניות'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Hebrew\n   */\n\n  var aliases$10 = ['il', 'he-il', 'hebrew'];\n  var heIl =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$10,\n    aliases: aliases$10\n  });\n  /**\n   * @classdesc Hungarian Language Pack\n   * @desc This class will used to translate tokens into the Hungarian language.\n   * @namespace Languages.Hungarian\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Hungarian\n   */\n\n  var dictionary$11 = {\n    'years': 'Év',\n    'months': 'Hónap',\n    'days': 'Nap',\n    'hours': 'Óra',\n    'minutes': 'Perc',\n    'seconds': 'Másodperc'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Hungarian\n   */\n\n  var aliases$11 = ['hu', 'hu-hu', 'hungarian'];\n  var huHu =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$11,\n    aliases: aliases$11\n  });\n  /**\n   * @classdesc Italian Language Pack\n   * @desc This class will used to translate tokens into the Italian language.\n   * @namespace Languages.Italian\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Italian\n   */\n\n  var dictionary$12 = {\n    'years': 'Anni',\n    'months': 'Mesi',\n    'days': 'Giorni',\n    'hours': 'Ore',\n    'minutes': 'Minuti',\n    'seconds': 'Secondi'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Italian\n   */\n\n  var aliases$12 = ['da', 'da-dk', 'danish'];\n  var itIt =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$12,\n    aliases: aliases$12\n  });\n  /**\n   * @classdesc Japanese Language Pack\n   * @desc This class will used to translate tokens into the Japanese language.\n   * @namespace Languages.Japanese\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Japanese\n   */\n\n  var dictionary$13 = {\n    'years': '年',\n    'months': '月',\n    'days': '日',\n    'hours': '時',\n    'minutes': '分',\n    'seconds': '秒'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Japanese\n   */\n\n  var aliases$13 = ['jp', 'ja-jp', 'japanese'];\n  var jaJp =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$13,\n    aliases: aliases$13\n  });\n  /**\n   * @classdesc Korean Language Pack\n   * @desc This class will used to translate tokens into the Korean language.\n   * @namespace Languages.Korean\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Korean\n   */\n\n  var dictionary$14 = {\n    'years': '년',\n    'months': '월',\n    'days': '일',\n    'hours': '시',\n    'minutes': '분',\n    'seconds': '초'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Korean\n   */\n\n  var aliases$14 = ['ko', 'ko-kr', 'korean'];\n  var koKr =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$14,\n    aliases: aliases$14\n  });\n  /**\n   * @classdesc Latvian Language Pack\n   * @desc This class will used to translate tokens into the Latvian language.\n   * @namespace Languages.Latvian\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Latvian\n   */\n\n  var dictionary$15 = {\n    'years': 'Gadi',\n    'months': 'Mēneši',\n    'days': 'Dienas',\n    'hours': 'Stundas',\n    'minutes': 'Minūtes',\n    'seconds': 'Sekundes'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Latvian\n   */\n\n  var aliases$15 = ['lv', 'lv-lv', 'latvian'];\n  var lvLv =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$15,\n    aliases: aliases$15\n  });\n  /**\n   * @classdesc Dutch Language Pack\n   * @desc This class will used to translate tokens into the Dutch language.\n   * @namespace Languages.Dutch\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Dutch\n   */\n\n  var dictionary$16 = {\n    'years': 'Jaren',\n    'months': 'Maanden',\n    'days': 'Dagen',\n    'hours': 'Uren',\n    'minutes': 'Minuten',\n    'seconds': 'Seconden'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Dutch\n   */\n\n  var aliases$16 = ['nl', 'nl-be', 'dutch'];\n  var nlBe =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$16,\n    aliases: aliases$16\n  });\n  /**\n   * @classdesc Norwegian-Bokmål Language Pack\n   * @desc This class will used to translate tokens into the Norwegian-Bokmål language.\n   * @namespace Languages.Norwegian\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Norwegian\n   */\n\n  var dictionary$17 = {\n    'years': 'År',\n    'months': 'Måneder',\n    'days': 'Dager',\n    'hours': 'Timer',\n    'minutes': 'Minutter',\n    'seconds': 'Sekunder'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Norwegian\n   */\n\n  var aliases$17 = ['no', 'nb', 'no-nb', 'norwegian'];\n  var noNb =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$17,\n    aliases: aliases$17\n  });\n  /**\n   * @classdesc Polish Language Pack\n   * @desc This class will used to translate tokens into the Polish language.\n   * @namespace Languages.Polish\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Polish\n   */\n\n  var dictionary$18 = {\n    'years': 'Lat',\n    'months': 'Miesięcy',\n    'days': 'Dni',\n    'hours': 'Godziny',\n    'minutes': 'Minuty',\n    'seconds': 'Sekundy'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Polish\n   */\n\n  var aliases$18 = ['pl', 'pl-pl', 'polish'];\n  var plPl =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$18,\n    aliases: aliases$18\n  });\n  /**\n   * @classdesc Portuguese Language Pack\n   * @desc This class will used to translate tokens into the Portuguese language.\n   * @namespace Languages.Portuguese\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Portuguese\n   */\n\n  var dictionary$19 = {\n    'years': 'Anos',\n    'months': 'Meses',\n    'days': 'Dias',\n    'hours': 'Horas',\n    'minutes': 'Minutos',\n    'seconds': 'Segundos'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Portuguese\n   */\n\n  var aliases$19 = ['pt', 'pt-br', 'portuguese'];\n  var ptBr =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$19,\n    aliases: aliases$19\n  });\n  /**\n   * @classdesc Romanian Language Pack\n   * @desc This class will used to translate tokens into the Romanian language.\n   * @namespace Languages.Romanian\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Romanian\n   */\n\n  var dictionary$20 = {\n    'years': 'Ani',\n    'months': 'Luni',\n    'days': 'Zile',\n    'hours': 'Ore',\n    'minutes': 'Minute',\n    'seconds': 'sSecunde'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Romanian\n   */\n\n  var aliases$20 = ['ro', 'ro-ro', 'romana'];\n  var roRo =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$20,\n    aliases: aliases$20\n  });\n  /**\n   * @classdesc Russian Language Pack\n   * @desc This class will used to translate tokens into the Russian language.\n   * @namespace Languages.Russian\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Russian\n   */\n\n  var dictionary$21 = {\n    'years': 'лет',\n    'months': 'месяцев',\n    'days': 'дней',\n    'hours': 'часов',\n    'minutes': 'минут',\n    'seconds': 'секунд'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Russian\n   */\n\n  var aliases$21 = ['ru', 'ru-ru', 'russian'];\n  var ruRu =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$21,\n    aliases: aliases$21\n  });\n  /**\n   * @classdesc Slovak Language Pack\n   * @desc This class will used to translate tokens into the Slovak language.\n   * @namespace Languages.Slovak\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Slovak\n   */\n\n  var dictionary$22 = {\n    'years': 'Roky',\n    'months': 'Mesiace',\n    'days': 'Dni',\n    'hours': 'Hodiny',\n    'minutes': 'Minúty',\n    'seconds': 'Sekundy'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Slovak\n   */\n\n  var aliases$22 = ['sk', 'sk-sk', 'slovak'];\n  var skSk =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$22,\n    aliases: aliases$22\n  });\n  /**\n   * @classdesc Swedish Language Pack\n   * @desc This class will used to translate tokens into the Swedish language.\n   * @namespace Languages.Swedish\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Swedish\n   */\n\n  var dictionary$23 = {\n    'years': 'År',\n    'months': 'Månader',\n    'days': 'Dagar',\n    'hours': 'Timmar',\n    'minutes': 'Minuter',\n    'seconds': 'Sekunder'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Swedish\n   */\n\n  var aliases$23 = ['sv', 'sv-se', 'swedish'];\n  var svSe =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$23,\n    aliases: aliases$23\n  });\n  /**\n   * @classdesc Thai Language Pack\n   * @desc This class will used to translate tokens into the Thai language.\n   * @namespace Languages.Thai\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Thai\n   */\n\n  var dictionary$24 = {\n    'years': 'ปี',\n    'months': 'เดือน',\n    'days': 'วัน',\n    'hours': 'ชั่วโมง',\n    'minutes': 'นาที',\n    'seconds': 'วินาที'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Thai\n   */\n\n  var aliases$24 = ['th', 'th-th', 'thai'];\n  var thTh =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$24,\n    aliases: aliases$24\n  });\n  /**\n   * @classdesc Turkish Language Pack\n   * @desc This class will used to translate tokens into the Turkish language.\n   * @namespace Languages.Turkish\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Turkish\n   */\n\n  var dictionary$25 = {\n    'years': 'Yıl',\n    'months': 'Ay',\n    'days': 'Gün',\n    'hours': 'Saat',\n    'minutes': 'Dakika',\n    'seconds': 'Saniye'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Turkish\n   */\n\n  var aliases$25 = ['tr', 'tr-tr', 'turkish'];\n  var trTr =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$25,\n    aliases: aliases$25\n  });\n  /**\n   * @classdesc Ukrainian Language Pack\n   * @desc This class will used to translate tokens into the Ukrainian language.\n   * @namespace Languages.Ukrainian\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Ukrainian\n   */\n\n  var dictionary$26 = {\n    'years': 'роки',\n    'months': 'місяці',\n    'days': 'дні',\n    'hours': 'години',\n    'minutes': 'хвилини',\n    'seconds': 'секунди'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Ukrainian\n   */\n\n  var aliases$26 = ['ua', 'ua-ua', 'ukraine'];\n  var uaUa =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$26,\n    aliases: aliases$26\n  });\n  /**\n   * @classdesc Vietnamese Language Pack\n   * @desc This class will used to translate tokens into the Vietnamese language.\n   * @namespace Languages.Vietnamese\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Vietnamese\n   */\n\n  var dictionary$27 = {\n    'years': 'Năm',\n    'months': 'Tháng',\n    'days': 'Ngày',\n    'hours': 'Giờ',\n    'minutes': 'Phút',\n    'seconds': 'Giây'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Vietnamese\n   */\n\n  var aliases$27 = ['vn', 'vn-vn', 'vietnamese'];\n  var vnVn =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$27,\n    aliases: aliases$27\n  });\n  /**\n   * @classdesc Chinese Language Pack\n   * @desc This class will used to translate tokens into the Chinese language.\n   * @namespace Languages.Chinese\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.Chinese\n   */\n\n  var dictionary$28 = {\n    'years': '年',\n    'months': '月',\n    'days': '日',\n    'hours': '时',\n    'minutes': '分',\n    'seconds': '秒'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.Chinese\n   */\n\n  var aliases$28 = ['zh', 'zh-cn', 'chinese'];\n  var zhCn =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$28,\n    aliases: aliases$28\n  });\n  /**\n   * @classdesc Traditional Chinese Language Pack\n   * @desc This class will used to translate tokens into the Traditional Chinese language.\n   * @namespace Languages.TraditionalChinese\n   */\n\n  /**\n   * @constant dictionary\n   * @type {object}\n   * @memberof Languages.TraditionalChinese\n   */\n\n  var dictionary$29 = {\n    'years': '年',\n    'months': '月',\n    'days': '日',\n    'hours': '時',\n    'minutes': '分',\n    'seconds': '秒'\n  };\n  /**\n   * @constant aliases\n   * @type {array}\n   * @memberof Languages.TraditionalChinese\n   */\n\n  var aliases$29 = ['zh-tw'];\n  var zhTw =\n  /*#__PURE__*/\n  Object.freeze({\n    dictionary: dictionary$29,\n    aliases: aliases$29\n  });\n  /**\n   * @namespace Languages\n   */\n\n  var LANGUAGES =\n  /*#__PURE__*/\n  Object.freeze({\n    Arabic: arAr,\n    Catalan: caEs,\n    Czech: csCz,\n    Danish: daDk,\n    German: deDe,\n    English: English,\n    Spanish: esEs,\n    Persian: faIr,\n    Finnish: fiFi,\n    French: frCa,\n    Hebrew: heIl,\n    Hungarian: huHu,\n    Italian: itIt,\n    Japanese: jaJp,\n    Korean: koKr,\n    Latvian: lvLv,\n    Dutch: nlBe,\n    Norwegian: noNb,\n    Polish: plPl,\n    Portuguese: ptBr,\n    Romanian: roRo,\n    Russian: ruRu,\n    Slovak: skSk,\n    Swedish: svSe,\n    Thai: thTh,\n    Turkish: trTr,\n    Ukrainian: uaUa,\n    Vietnamese: vnVn,\n    Chinese: zhCn,\n    TraditionalChinese: zhTw\n  });\n  /**\n   * @namespace Helpers.Language\n   */\n\n  /**\n   * Return the language associated with the key. Returns `null` if no language is\n   * found.\n   * \n   * @function language\n   * @param  {string} name - The name or id of the language.\n   * @return {object|null} - The language dictionary, or null if not found.\n   * @memberof Helpers.Language\n   */\n\n  function language(name) {\n    return name ? LANGUAGES[name.toLowerCase()] || Object.values(LANGUAGES).find(function (value) {\n      return value.aliases.indexOf(name) !== -1;\n    }) : null;\n  }\n  /**\n   * @namespace Helpers.Translate\n   */\n\n  /**\n   * Translate an English string into another language.\n   * \n   * @function translate\n   * @param {string} string - The string to translate.\n   * @param {(string|object)} from - The language used to translate. If a string,\n   *     the language is loaded into an object.\n   * @return {string} - If no diction key is found, the untranslated string is\n   *     returned.\n   * @memberof Helpers.Translate\n   */\n\n\n  function translate(string, from) {\n    var lang = isString(from) ? language(from) : from;\n    var dictionary = lang.dictionary || lang;\n    return dictionary[string] || string;\n  }\n  /**\n   * A collection of functions to manage DOM nodes and theme templates.\n   *\n   * @namespace Helpers.Template\n   */\n\n  /**\n   * Swap a new DOM node with an existing one.\n   *\n   * @function swap\n   * @param  {HTMLElement} subject - The new DOM node.\n   * @param  {HTMLElement} existing - The existing DOM node.\n   * @return {HTMLElement} - Returns the new element if it was mounted, otherwise\n   *    the existing node is returned.\n   * @memberof Helpers.Template\n   */\n\n\n  function swap(subject, existing) {\n    if (existing.parentNode) {\n      existing.parentNode.replaceChild(subject, existing);\n      return subject;\n    }\n\n    return existing;\n  }\n  /**\n   * Set the attribute of an element.\n   *\n   * @function setAttributes\n   * @param  {HTMLElement} el - The DOM node that will receive the attributes.\n   * @param  {Object|undefined} [attributes] - The attribute object, or if no object\n   *     is passed, then the action is ignored.\n   * @return {HTMLElement} el - The DOM node that received the attributes.\n   * @memberof Helpers.Template\n   */\n\n\n  function setAttributes(el, attributes) {\n    if (isObject(attributes)) {\n      for (var i in attributes) {\n        el.setAttribute(i, attributes[i]);\n      }\n    }\n\n    return el;\n  }\n  /**\n   * Append an array of DOM nodes to a parent.\n   *\n   * @function appendChildren\n   * @param  {HTMLElement} el - The parent DOM node.\n   * @param  {Array|undefined} [children] - The array of children. If no array\n   *     is passed, then the method silently fails to run.\n   * @return {HTMLElement} el - The DOM node that received the attributes.\n   * @memberof Helpers.Template\n   */\n\n\n  function appendChildren(el, children) {\n    if (isArray(children)) {\n      children.filter(noop).forEach(function (child) {\n        if (child instanceof HTMLElement) {\n          el.appendChild(child);\n        }\n      });\n    }\n\n    return el;\n  }\n  /**\n   * Create a new HTMLElement instance.\n   *\n   * @function createElement\n   * @param  {HTMLElement} el - The parent DOM node.\n   * @param  {Array|undefined} [children] - The array of children. If no array\n   *     is passed, then the method silently fails to run.\n   * @param  {Object|undefined} [attributes] - The attributes object.\n   * @return {HTMLElement} el - The DOM node that received the attributes.\n   * @memberof Helpers.Template\n   */\n\n\n  function createElement(el, children, attributes) {\n    if (!(el instanceof HTMLElement)) {\n      el = document.createElement(el);\n    }\n\n    setAttributes(el, isObject(children) ? children : attributes);\n\n    if (!isObject(children) && !isArray(children)) {\n      el.innerHTML = children;\n    } else {\n      appendChildren(el, children);\n    }\n\n    return el;\n  }\n\n  var DomComponent =\n  /*#__PURE__*/\n  function (_Component) {\n    _inherits(DomComponent, _Component);\n    /**\n     * An abstract class that all other DOM components can extend.\n     *\n     * @class DomComponent\n     * @extends Component\n     * @param {(object|undefined)} [attributes] - The instance attributes.\n     */\n\n\n    function DomComponent(attributes) {\n      var _this;\n\n      _classCallCheck(this, DomComponent);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(DomComponent).call(this, Object.assign({\n        parent: null\n      }, attributes)));\n\n      if (!_this.theme) {\n        error(\"\".concat(_this.name, \" does not have a theme defined.\"));\n      }\n\n      if (!_this.language) {\n        error(\"\".concat(_this.name, \" does not have a language defined.\"));\n      }\n\n      if (!_this.theme[_this.name]) {\n        throw new Error(\"\".concat(_this.name, \" cannot be rendered because it has no template.\"));\n      }\n\n      return _this;\n    }\n    /**\n     * The `className` attribute. Used for CSS.\n     *\n     * @type {string}\n     */\n\n\n    _createClass(DomComponent, [{\n      key: \"translate\",\n\n      /**\n       * Translate a string.\n       *\n       * @param  {string} string - The string to translate.\n       * @return {string} - The translated string. If no tranlation found, the\n       *     untranslated string is returned.\n       */\n      value: function translate$$1(string) {\n        return translate(string, this.language);\n      }\n      /**\n       * Alias to translate(string);\n       *\n       * @alias DomComponent.translate\n       */\n\n    }, {\n      key: \"t\",\n      value: function t(string) {\n        return this.translate(string);\n      }\n      /**\n       * Render the DOM component.\n       *\n       * @return {HTMLElement} - The `el` attribute.\n       */\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        var el = createElement('div', {\n          \"class\": this.className === 'flip-clock' ? this.className : 'flip-clock-' + this.className\n        });\n        this.theme[this.name](el, this);\n\n        if (!this.el) {\n          this.el = el;\n        } else if (this.el.innerHTML !== el.innerHTML) {\n          this.el = swap(el, this.el);\n        }\n\n        return this.el;\n      }\n      /**\n       * Mount a DOM component to a parent node.\n       *\n       * @param  {HTMLElement} parent - The parent DOM node.\n       * @param  {(false|HTMLElement)} [before=false] - If `false`, element is\n       *     appended to the parent node. If an instance of an `HTMLElement`,\n       *     the component will be inserted before the specified element.\n       * @return {HTMLElement} - The `el` attribute.\n       */\n\n    }, {\n      key: \"mount\",\n      value: function mount(parent) {\n        var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        this.render();\n        this.parent = parent;\n\n        if (!before) {\n          this.parent.appendChild(this.el);\n        } else {\n          this.parent.insertBefore(this.el, before);\n        }\n\n        return this.el;\n      }\n    }, {\n      key: \"className\",\n      get: function get() {\n        return kebabCase(this.constructor.defineName());\n      }\n      /**\n       * The `el` attribute.\n       *\n       * @type {HTMLElement}\n       */\n\n    }, {\n      key: \"el\",\n      get: function get() {\n        return this.$el;\n      },\n      set: function set(value) {\n        if (!validate(value, null, HTMLElement)) {\n          error(ConsoleMessages.element);\n        }\n\n        this.$el = value;\n      }\n      /**\n       * The `parent` attribute. Parent is set when `DomComponent` instances are\n       * mounted.\n       *\n       * @type {DomComponent}\n       */\n\n    }, {\n      key: \"parent\",\n      get: function get() {\n        return this.$parent;\n      },\n      set: function set(parent) {\n        this.$parent = parent;\n      }\n      /**\n       * The `theme` attribute.\n       *\n       * @type {object}\n       */\n\n    }, {\n      key: \"theme\",\n      get: function get() {\n        return this.$theme;\n      },\n      set: function set(value) {\n        if (!validate(value, 'object')) {\n          error(ConsoleMessages.value);\n        }\n\n        this.$theme = value;\n      }\n      /**\n       * Get the language attribute.\n       *\n       * @type {object}\n       */\n\n    }, {\n      key: \"language\",\n      get: function get() {\n        return this.$language;\n      },\n      set: function set(value) {\n        if (isString(value)) {\n          value = language(value);\n        }\n\n        if (!validate(value, 'object')) {\n          error(ConsoleMessages.language);\n        }\n\n        this.$language = value;\n      }\n    }]);\n\n    return DomComponent;\n  }(Component);\n  /**\n   * Create a new `Divider` instance.\n   *\n   * The purpose of this class is to return a unique class name so the theme can\n   * render it appropriately, since each `DomComponent` can receive its own template\n   * from the theme.\n   *\n   * @class Divider\n   * @extends DomComponent\n   * @param {(object|undefined)} [attributes] - The instance attributes.\n   */\n\n\n  var Divider =\n  /*#__PURE__*/\n  function (_DomComponent) {\n    _inherits(Divider, _DomComponent);\n\n    function Divider() {\n      _classCallCheck(this, Divider);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Divider).apply(this, arguments));\n    }\n\n    _createClass(Divider, null, [{\n      key: \"defineName\",\n\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n      value: function defineName() {\n        return 'Divider';\n      }\n    }]);\n\n    return Divider;\n  }(DomComponent);\n\n  var ListItem =\n  /*#__PURE__*/\n  function (_DomComponent) {\n    _inherits(ListItem, _DomComponent);\n    /**\n     * This class is used to represent a single digits in a `List`.\n     *\n     * @class ListItem\n     * @extends DomComponent\n     * @param {(Number|String)} value - The value of the `ListItem`.\n     * @param {object|undefined} [attributes] - The instance attributes.\n     */\n\n\n    function ListItem(value, attributes) {\n      _classCallCheck(this, ListItem);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ListItem).call(this, Object.assign({\n        value: value\n      }, isObject(value) ? value : null, attributes)));\n    }\n    /**\n     * Define the name of the class.\n     *\n     * @return {string}\n     */\n\n\n    _createClass(ListItem, null, [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'ListItem';\n      }\n    }]);\n\n    return ListItem;\n  }(DomComponent);\n\n  var List =\n  /*#__PURE__*/\n  function (_DomComponent) {\n    _inherits(List, _DomComponent);\n    /**\n     * This class is used to add a digit to the clock face. This class is called\n     * `List` because it contains a list of `ListItem`'s which are used to\n     * create flip effects. In the context of FlipClock.js a `List` represents\n     * one single digit.\n     *\n     * @class List\n     * @extends DomComponent\n     * @param {Number|String|Object} label - The active value. If an object, it\n     * is assumed that it is the instance attributes.\n     * @param {object|undefined} [attributes] - The instance attributes.\n     */\n\n\n    function List(value, attributes) {\n      _classCallCheck(this, List);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(List).call(this, Object.assign({\n        value: value,\n        items: []\n      }, isObject(value) ? value : null, attributes)));\n    }\n    /**\n     * Get the `value` attribute.\n     *\n     * @type {(Number|String)}\n     */\n\n\n    _createClass(List, [{\n      key: \"createListItem\",\n\n      /**\n       * Helper method to instantiate a new `ListItem`.\n       *\n       * @param  {(Number|String)} value - The `ListItem` value.\n       * @param  {(Object|undefined)} [attributes] - The instance attributes.\n       * @return {ListItem} - The instantiated `ListItem`.\n       */\n      value: function createListItem(value, attributes) {\n        var item = new ListItem(value, Object.assign({\n          theme: this.theme,\n          language: this.language\n        }, attributes));\n        this.$items.push(item);\n        return item;\n      }\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n\n    }, {\n      key: \"value\",\n      get: function get() {\n        return this.$value;\n      },\n      set: function set(value) {\n        this.$value = value;\n      }\n      /**\n       * Get the `items` attribute.\n       *\n       * @type {(Number|String)}\n       */\n\n    }, {\n      key: \"items\",\n      get: function get() {\n        return this.$items;\n      },\n      set: function set(value) {\n        this.$items = value;\n      }\n    }], [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'List';\n      }\n    }]);\n\n    return List;\n  }(DomComponent);\n\n  var Group =\n  /*#__PURE__*/\n  function (_DomComponent) {\n    _inherits(Group, _DomComponent);\n    /**\n     * This class is used to group values within a clock face. How the groups\n     * are displayed is determined by the theme.\n     *\n     * @class Group\n     * @extends DomComponent\n     * @param {Array|Object} items - An array `List` instances or an object of\n     *     attributes. If not an array, assumed to be the attributes.\n     * @param {object|undefined} [attributes] - The instance attributes.\n     */\n\n\n    function Group(items, attributes) {\n      _classCallCheck(this, Group);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Group).call(this, Object.assign({\n        items: isArray(items) ? items : []\n      }, isObject(items) ? items : null, attributes)));\n    }\n    /**\n     * Define the name of the class.\n     *\n     * @return {string}\n     */\n\n\n    _createClass(Group, null, [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'Group';\n      }\n    }]);\n\n    return Group;\n  }(DomComponent);\n\n  var Label =\n  /*#__PURE__*/\n  function (_DomComponent) {\n    _inherits(Label, _DomComponent);\n    /**\n     * This class is used to add a label to the clock face.\n     *\n     * @class Label\n     * @extends DomComponent\n     * @param {Number|String|Object} label - The label attribute. If an object,\n     *     it is assumed that it is the instance attributes.\n     * @param {object|undefined} [attributes] - The instance attributes.\n     */\n\n\n    function Label(label, attributes) {\n      _classCallCheck(this, Label);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Label).call(this, Object.assign({\n        label: label\n      }, isObject(label) ? label : null, attributes)));\n    }\n    /**\n     * Define the name of the class.\n     *\n     * @return {string}\n     */\n\n\n    _createClass(Label, null, [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'Label';\n      }\n    }]);\n\n    return Label;\n  }(DomComponent);\n\n  var Timer =\n  /*#__PURE__*/\n  function (_Component) {\n    _inherits(Timer, _Component);\n    /**\n     * Create a new `Timer` instance.\n     *\n     * @class Timer\n     * @extends Component\n     * @param {(Object|Number)} interval - The interval passed as a `Number`,\n     *     or can set the attribute of the class with an object.\n     */\n\n\n    function Timer(interval) {\n      _classCallCheck(this, Timer);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Timer).call(this, Object.assign({\n        count: 0,\n        handle: null,\n        started: null,\n        running: false,\n        interval: isNumber(interval) ? interval : null\n      }, isObject(interval) ? interval : null)));\n    }\n    /**\n     * The `elapsed` attribute.\n     *\n     * @type {Number}\n     */\n\n\n    _createClass(Timer, [{\n      key: \"reset\",\n\n      /**\n       * Resets the timer.\n       *\n       * @param  {(Function|undefined)} fn - The interval callback.\n       * @return {Timer} - The `Timer` instance.\n       */\n      value: function reset(fn) {\n        var _this = this;\n\n        this.stop(function () {\n          _this.count = 0;\n\n          _this.start(function () {\n            return callback.call(_this, fn);\n          });\n\n          _this.emit('reset');\n        });\n        return this;\n      }\n      /**\n       * Starts the timer.\n       *\n       * @param  {Function} fn - The interval callback.\n       * @return {Timer} - The `Timer` instance.\n       */\n\n    }, {\n      key: \"start\",\n      value: function start(fn) {\n        var _this2 = this;\n\n        this.started = new Date();\n        this.lastLoop = Date.now();\n        this.running = true;\n        this.emit('start');\n\n        var loop = function loop() {\n          if (Date.now() - _this2.lastLoop >= _this2.interval) {\n            callback.call(_this2, fn);\n            _this2.lastLoop = Date.now();\n\n            _this2.emit('interval');\n\n            _this2.count++;\n          }\n\n          _this2.handle = window.requestAnimationFrame(loop);\n          return _this2;\n        };\n\n        return loop();\n      }\n      /**\n       * Stops the timer.\n       *\n       * @param  {Function} fn - The stop callback.\n       * @return {Timer} - The `Timer` instance.\n       */\n\n    }, {\n      key: \"stop\",\n      value: function stop(fn) {\n        var _this3 = this;\n\n        if (this.isRunning) {\n          setTimeout(function () {\n            window.cancelAnimationFrame(_this3.handle);\n            _this3.running = false;\n            callback.call(_this3, fn);\n\n            _this3.emit('stop');\n          });\n        }\n\n        return this;\n      }\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n\n    }, {\n      key: \"elapsed\",\n      get: function get() {\n        return !this.lastLoop ? 0 : this.lastLoop - (this.started ? this.started.getTime() : new Date().getTime());\n      }\n      /**\n       * The `isRunning` attribute.\n       *\n       * @type {boolean}\n       */\n\n    }, {\n      key: \"isRunning\",\n      get: function get() {\n        return this.running === true;\n      }\n      /**\n       * The `isStopped` attribute.\n       *\n       * @type {boolean}\n       */\n\n    }, {\n      key: \"isStopped\",\n      get: function get() {\n        return this.running === false;\n      }\n    }], [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'Timer';\n      }\n    }]);\n\n    return Timer;\n  }(Component);\n  /**\n   * @classdesc This face is designed to increment and decrement numberic values,\n   *     not `Date` objects.\n   * @extends Face\n   * @param {(FaceValue|object)} value - The `Face` value. If not an instance\n   *     of FaceValue, this argument is assumed to be the instance attributes.\n   * @param {(object|undefined)} [attributes] - The instance attributes.\n   * @memberof Faces\n   */\n\n\n  var Counter =\n  /*#__PURE__*/\n  function (_Face) {\n    _inherits(Counter, _Face);\n\n    function Counter() {\n      _classCallCheck(this, Counter);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Counter).apply(this, arguments));\n    }\n\n    _createClass(Counter, [{\n      key: \"increment\",\n      value: function increment(instance) {\n        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        instance.value = this.value.value + value;\n      }\n    }, {\n      key: \"decrement\",\n      value: function decrement(instance) {\n        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        instance.value = this.value.value - value;\n      }\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n\n    }], [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'Counter';\n      }\n    }]);\n\n    return Counter;\n  }(Face);\n  /**\n   * @classdesc This face is meant to display a clock that shows minutes, and\n   *     seconds.\n   * @extends Face\n   * @param {(FaceValue|object)} value - The `Face` value. If not an instance\n   *     of FaceValue, this argument is assumed to be the instance attributes.\n   * @param {(object|undefined)} [attributes] - The instance attributes.\n   * @memberof Faces\n   */\n\n\n  var MinuteCounter =\n  /*#__PURE__*/\n  function (_Face) {\n    _inherits(MinuteCounter, _Face);\n\n    function MinuteCounter() {\n      _classCallCheck(this, MinuteCounter);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(MinuteCounter).apply(this, arguments));\n    }\n\n    _createClass(MinuteCounter, [{\n      key: \"defaultDataType\",\n      value: function defaultDataType() {\n        return Date;\n      }\n    }, {\n      key: \"defaultAttributes\",\n      value: function defaultAttributes() {\n        return {\n          showSeconds: true,\n          showLabels: true\n        };\n      }\n    }, {\n      key: \"shouldStop\",\n      value: function shouldStop(instance) {\n        if (isNull(instance.stopAt) || isUndefined(instance.stopAt)) {\n          return false;\n        }\n\n        if (this.stopAt instanceof Date) {\n          return this.countdown ? this.stopAt.getTime() >= this.value.value.getTime() : this.stopAt.getTime() <= this.value.value.getTime();\n        } else if (isNumber(this.stopAt)) {\n          var diff = Math.floor((this.value.value.getTime() - this.originalValue.getTime()) / 1000);\n          return this.countdown ? this.stopAt >= diff : this.stopAt <= diff;\n        }\n\n        throw new Error(\"the stopAt property must be an instance of Date or Number.\");\n      }\n    }, {\n      key: \"increment\",\n      value: function increment(instance) {\n        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        instance.value = new Date(this.value.value.getTime() + value + (new Date().getTime() - instance.timer.lastLoop));\n      }\n    }, {\n      key: \"decrement\",\n      value: function decrement(instance) {\n        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        instance.value = new Date(this.value.value.getTime() - value - (new Date().getTime() - instance.timer.lastLoop));\n      }\n    }, {\n      key: \"format\",\n      value: function format(instance, value) {\n        var started = instance.timer.isRunning ? instance.timer.started : new Date(Date.now() - 50);\n        return [[this.getMinutes(value, started)], this.showSeconds ? [this.getSeconds(value, started)] : null].filter(noop);\n      }\n    }, {\n      key: \"getMinutes\",\n      value: function getMinutes(a, b) {\n        return round(this.getTotalSeconds(a, b) / 60);\n      }\n    }, {\n      key: \"getSeconds\",\n      value: function getSeconds(a, b) {\n        var totalSeconds = this.getTotalSeconds(a, b);\n        return Math.abs(Math.ceil(totalSeconds === 60 ? 0 : totalSeconds % 60));\n      }\n    }, {\n      key: \"getTotalSeconds\",\n      value: function getTotalSeconds(a, b) {\n        return a.getTime() === b.getTime() ? 0 : Math.round((a.getTime() - b.getTime()) / 1000);\n      }\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n\n    }], [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'MinuteCounter';\n      }\n    }]);\n\n    return MinuteCounter;\n  }(Face);\n  /**\n   * @classdesc This face is meant to display a clock that shows\n   *     hours, minutes, and seconds.\n   * @extends Face\n   * @param {(FaceValue|object)} value - The `Face` value. If not an instance\n   *     of FaceValue, this argument is assumed to be the instance attributes.\n   * @param {(object|undefined)} [attributes] - The instance attributes.\n   * @memberof Faces\n   */\n\n\n  var HourCounter =\n  /*#__PURE__*/\n  function (_MinuteCounter) {\n    _inherits(HourCounter, _MinuteCounter);\n\n    function HourCounter() {\n      _classCallCheck(this, HourCounter);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(HourCounter).apply(this, arguments));\n    }\n\n    _createClass(HourCounter, [{\n      key: \"format\",\n      value: function format(instance, value) {\n        var now = !instance.timer.started ? new Date() : value;\n        var originalValue = instance.originalValue || value;\n        var a = !this.countdown ? now : originalValue;\n        var b = !this.countdown ? originalValue : now;\n        var data = [[this.getHours(a, b)], [this.getMinutes(a, b)]];\n\n        if (this.showSeconds) {\n          data.push([this.getSeconds(a, b)]);\n        }\n\n        return data;\n      }\n    }, {\n      key: \"getMinutes\",\n      value: function getMinutes(a, b) {\n        return Math.abs(_get(_getPrototypeOf(HourCounter.prototype), \"getMinutes\", this).call(this, a, b) % 60);\n      }\n    }, {\n      key: \"getHours\",\n      value: function getHours(a, b) {\n        return Math.floor(this.getTotalSeconds(a, b) / 60 / 60);\n      }\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n\n    }], [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'HourCounter';\n      }\n    }]);\n\n    return HourCounter;\n  }(MinuteCounter);\n  /**\n   * @classdesc This face is meant to display a clock that shows days, hours,\n   *     minutes, and seconds.\n   * @extends HourCounter\n   * @param {(FaceValue|object)} value - The `Face` value. If not an instance\n   *     of FaceValue, this argument is assumed to be the instance attributes.\n   * @param {(object|undefined)} [attributes] - The instance attributes.\n   * @memberof Faces\n   */\n\n\n  var DayCounter =\n  /*#__PURE__*/\n  function (_HourCounter) {\n    _inherits(DayCounter, _HourCounter);\n\n    function DayCounter() {\n      _classCallCheck(this, DayCounter);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DayCounter).apply(this, arguments));\n    }\n\n    _createClass(DayCounter, [{\n      key: \"format\",\n      value: function format(instance, value) {\n        var now = !instance.started ? new Date() : value;\n        var originalValue = instance.originalValue || value;\n        var a = !this.countdown ? now : originalValue;\n        var b = !this.countdown ? originalValue : now;\n        var data = [[this.getDays(a, b)], [this.getHours(a, b)], [this.getMinutes(a, b)]];\n\n        if (this.showSeconds) {\n          data.push([this.getSeconds(a, b)]);\n        }\n\n        return data;\n      }\n    }, {\n      key: \"getDays\",\n      value: function getDays(a, b) {\n        return Math.floor(this.getTotalSeconds(a, b) / 60 / 60 / 24);\n      }\n    }, {\n      key: \"getHours\",\n      value: function getHours(a, b) {\n        return Math.abs(_get(_getPrototypeOf(DayCounter.prototype), \"getHours\", this).call(this, a, b) % 24);\n      }\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n\n    }], [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'DayCounter';\n      }\n    }]);\n\n    return DayCounter;\n  }(HourCounter);\n  /**\n   * @classdesc This face shows the current time in twenty-four hour format.\n   * @extends Face\n   * @param {(FaceValue|object)} value - The `Face` value. If not an instance\n   *     of FaceValue, this argument is assumed to be the instance attributes.\n   * @param {(object|undefined)} [attributes] - The instance attributes.\n   * @memberof Faces\n   */\n\n\n  var TwentyFourHourClock =\n  /*#__PURE__*/\n  function (_Face) {\n    _inherits(TwentyFourHourClock, _Face);\n\n    function TwentyFourHourClock() {\n      _classCallCheck(this, TwentyFourHourClock);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(TwentyFourHourClock).apply(this, arguments));\n    }\n\n    _createClass(TwentyFourHourClock, [{\n      key: \"defaultDataType\",\n      value: function defaultDataType() {\n        return Date;\n      }\n    }, {\n      key: \"defaultValue\",\n      value: function defaultValue() {\n        return new Date();\n      }\n    }, {\n      key: \"defaultAttributes\",\n      value: function defaultAttributes() {\n        return {\n          showSeconds: true,\n          showLabels: false\n        };\n      }\n    }, {\n      key: \"format\",\n      value: function format(instance, value) {\n        if (!value) {\n          value = new Date();\n        }\n\n        var groups = [[value.getHours()], [value.getMinutes()]];\n\n        if (this.showSeconds) {\n          groups.push([value.getSeconds()]);\n        }\n\n        return groups;\n      }\n    }, {\n      key: \"increment\",\n      value: function increment(instance) {\n        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        instance.value = new Date(this.value.value.getTime() + offset + (new Date().getTime() - instance.timer.lastLoop));\n      }\n    }, {\n      key: \"decrement\",\n      value: function decrement(instance) {\n        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        instance.value = new Date(this.value.value.getTime() - offset - (new Date().getTime() - instance.timer.lastLoop));\n      }\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n\n    }], [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'TwentyFourHourClock';\n      }\n    }]);\n\n    return TwentyFourHourClock;\n  }(Face);\n  /**\n   * @classdesc This face shows the current time in twelve hour format, with AM\n   *     and PM.\n   * @extends Face\n   * @param {(FaceValue|object)} value - The `Face` value. If not an instance\n   *     of FaceValue, this argument is assumed to be the instance attributes.\n   * @param {(object|undefined)} [attributes] - The instance attributes.\n   * @memberof Faces\n   */\n\n\n  var TwelveHourClock =\n  /*#__PURE__*/\n  function (_TwentyFourHourClock) {\n    _inherits(TwelveHourClock, _TwentyFourHourClock);\n\n    function TwelveHourClock() {\n      _classCallCheck(this, TwelveHourClock);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(TwelveHourClock).apply(this, arguments));\n    }\n\n    _createClass(TwelveHourClock, [{\n      key: \"defaultAttributes\",\n      value: function defaultAttributes() {\n        return {\n          showLabels: false,\n          showSeconds: true,\n          showMeridium: true\n        };\n      }\n    }, {\n      key: \"format\",\n      value: function format(instance, value) {\n        if (!value) {\n          value = new Date();\n        }\n\n        var hours = value.getHours();\n        var groups = [hours > 12 ? hours - 12 : hours === 0 ? 12 : hours, value.getMinutes()];\n        this.meridium = hours > 12 ? 'pm' : 'am';\n\n        if (this.showSeconds) {\n          groups.push(value.getSeconds());\n        }\n\n        return groups;\n      }\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n\n    }], [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'TwelveHourClock';\n      }\n    }]);\n\n    return TwelveHourClock;\n  }(TwentyFourHourClock);\n  /**\n   * @classdesc This face is meant to display a clock that shows weeks, days,\n   *     hours, minutes, and seconds.\n   * @extends Face\n   * @param {(FaceValue|object)} value - The `Face` value. If not an instance\n   *     of FaceValue, this argument is assumed to be the instance attributes.\n   * @param {(object|undefined)} [attributes] - The instance attributes.\n   * @memberof Faces\n   */\n\n\n  var WeekCounter =\n  /*#__PURE__*/\n  function (_DayCounter) {\n    _inherits(WeekCounter, _DayCounter);\n\n    function WeekCounter() {\n      _classCallCheck(this, WeekCounter);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(WeekCounter).apply(this, arguments));\n    }\n\n    _createClass(WeekCounter, [{\n      key: \"format\",\n      value: function format(instance, value) {\n        var now = !instance.timer.started ? new Date() : value;\n        var originalValue = instance.originalValue || value;\n        var a = !this.countdown ? now : originalValue;\n        var b = !this.countdown ? originalValue : now;\n        var data = [[this.getWeeks(a, b)], [this.getDays(a, b)], [this.getHours(a, b)], [this.getMinutes(a, b)]];\n\n        if (this.showSeconds) {\n          data.push([this.getSeconds(a, b)]);\n        }\n\n        return data;\n      }\n    }, {\n      key: \"getWeeks\",\n      value: function getWeeks(a, b) {\n        return Math.floor(this.getTotalSeconds(a, b) / 60 / 60 / 24 / 7);\n      }\n    }, {\n      key: \"getDays\",\n      value: function getDays(a, b) {\n        return Math.abs(_get(_getPrototypeOf(WeekCounter.prototype), \"getDays\", this).call(this, a, b) % 7);\n      }\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n\n    }], [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'WeekCounter';\n      }\n    }]);\n\n    return WeekCounter;\n  }(DayCounter);\n  /**\n   * @classdesc This face is meant to display a clock that shows years, weeks,\n   *     days, hours, minutes, and seconds.\n   * @extends Face\n   * @param {(FaceValue|object)} value - The `Face` value. If not an instance\n   *     of FaceValue, this argument is assumed to be the instance attributes.\n   * @param {(object|undefined)} [attributes] - The instance attributes.\n   * @memberof Faces\n   */\n\n\n  var YearCounter =\n  /*#__PURE__*/\n  function (_WeekCounter) {\n    _inherits(YearCounter, _WeekCounter);\n\n    function YearCounter() {\n      _classCallCheck(this, YearCounter);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(YearCounter).apply(this, arguments));\n    }\n\n    _createClass(YearCounter, [{\n      key: \"format\",\n      value: function format(instance, value) {\n        var now = !instance.timer.started ? new Date() : value;\n        var originalValue = instance.originalValue || value;\n        var a = !this.countdown ? now : originalValue;\n        var b = !this.countdown ? originalValue : now;\n        var data = [[this.getYears(a, b)], [this.getWeeks(a, b)], [this.getDays(a, b)], [this.getHours(a, b)], [this.getMinutes(a, b)]];\n\n        if (this.showSeconds) {\n          data.push([this.getSeconds(a, b)]);\n        }\n\n        return data;\n      }\n    }, {\n      key: \"getYears\",\n      value: function getYears(a, b) {\n        return Math.floor(Math.max(0, this.getTotalSeconds(a, b) / 60 / 60 / 24 / 7 / 52));\n      }\n    }, {\n      key: \"getWeeks\",\n      value: function getWeeks(a, b) {\n        return Math.abs(_get(_getPrototypeOf(YearCounter.prototype), \"getWeeks\", this).call(this, a, b) % 52);\n      }\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n\n    }], [{\n      key: \"defineName\",\n      value: function defineName() {\n        return 'YearCounter';\n      }\n    }]);\n\n    return YearCounter;\n  }(WeekCounter);\n  /**\n   * Faces are classes that hook into the core of Flipclock to provide unique\n   * functionality. The core doesn't do a lot, except facilitate the interaction\n   * between all the components. The Face is what makes the clock \"tick\".\n   *\n   * @namespace Faces\n   */\n\n\n  var Faces =\n  /*#__PURE__*/\n  Object.freeze({\n    Counter: Counter,\n    DayCounter: DayCounter,\n    MinuteCounter: MinuteCounter,\n    HourCounter: HourCounter,\n    TwelveHourClock: TwelveHourClock,\n    TwentyFourHourClock: TwentyFourHourClock,\n    WeekCounter: WeekCounter,\n    YearCounter: YearCounter\n  });\n\n  function Divider$1(el, instance) {\n    appendChildren(el, [createElement('div', {\n      \"class\": 'flip-clock-dot top'\n    }), createElement('div', {\n      \"class\": 'flip-clock-dot bottom'\n    })]);\n  }\n\n  function child(el, index) {\n    return el ? el.childNodes ? el.childNodes[index] : el[index] : null;\n  }\n\n  function _char(el) {\n    return el ? el.querySelector('.flip-clock-list-item:first-child .top').innerHTML : null;\n  }\n\n  function FlipClock(el, instance) {\n    var parts = instance.value.digits.map(function (group, x) {\n      var groupEl = child(instance.el ? instance.el.querySelectorAll('.flip-clock-group') : null, x);\n      var lists = group.map(function (value, y) {\n        var listEl = child(groupEl ? groupEl.querySelectorAll('.flip-clock-list') : null, y);\n\n        var listValue = _char(listEl);\n\n        return instance.createList(value, {\n          domValue: listValue,\n          countdown: instance.countdown,\n          animationRate: instance.face.animationRate || instance.face.delay\n        });\n      });\n      return instance.createGroup(lists);\n    });\n    var nodes = parts.map(function (group) {\n      return group.render();\n    });\n    appendChildren(el, nodes);\n  }\n\n  function Group$1(el, instance) {\n    var items = instance.items.map(function (item) {\n      return item.render();\n    });\n    appendChildren(el, items);\n  }\n\n  function Label$1(el, instance) {\n    el.innerHTML = instance.t(instance.label);\n  }\n\n  function List$1(el, instance) {\n    var beforeValue = instance.domValue || (!instance.countdown ? prev(instance.value) : next(instance.value));\n\n    if (instance.domValue && instance.domValue !== instance.value) {\n      el.classList.add('flip');\n    }\n\n    el.style.animationDelay = \"\".concat(instance.animationRate / 2, \"ms\");\n    el.style.animationDuration = \"\".concat(instance.animationRate / 2, \"ms\");\n    instance.items = [instance.createListItem(instance.value, {\n      active: true\n    }), instance.createListItem(beforeValue, {\n      active: false\n    })];\n    appendChildren(el, instance.items.map(function (item) {\n      return item.render();\n    }));\n  }\n\n  function ListItem$1(el, instance) {\n    var className = instance.active === true ? 'active' : instance.active === false ? 'before' : null;\n    el.classList.add(className);\n    appendChildren(el, [createElement('div', [createElement('div', instance.value, {\n      \"class\": 'top'\n    }), createElement('div', instance.value, {\n      \"class\": 'bottom'\n    })], {\n      \"class\": 'flip-clock-list-item-inner'\n    })]);\n  }\n\n  function DayCounter$1(el, instance) {\n    instance.createDivider().mount(el, el.childNodes[1]);\n    instance.createDivider().mount(el, el.childNodes[3]);\n\n    if (instance.face.showSeconds) {\n      instance.createDivider().mount(el, el.childNodes[5]);\n    }\n\n    if (instance.face.showLabels) {\n      instance.createLabel('days').mount(el.childNodes[0]);\n      instance.createLabel('hours').mount(el.childNodes[2]);\n      instance.createLabel('minutes').mount(el.childNodes[4]);\n\n      if (instance.face.showSeconds) {\n        instance.createLabel('seconds').mount(el.childNodes[6]);\n      }\n    }\n  }\n\n  function HourCounter$1(el, instance) {\n    instance.createDivider().mount(el, el.childNodes[1]);\n\n    if (instance.face.showSeconds) {\n      instance.createDivider().mount(el, el.childNodes[3]);\n    }\n\n    if (instance.face.showLabels) {\n      instance.createLabel('hours').mount(el.childNodes[0]);\n      instance.createLabel('minutes').mount(el.childNodes[2]);\n\n      if (instance.face.showSeconds) {\n        instance.createLabel('seconds').mount(el.childNodes[4]);\n      }\n    }\n  }\n\n  function MinuteCounter$1(el, instance) {\n    if (instance.face.showSeconds) {\n      instance.createDivider().mount(el, el.childNodes[1]);\n    }\n\n    if (instance.face.showLabels) {\n      instance.createLabel('minutes').mount(el.childNodes[0]);\n\n      if (instance.face.showSeconds) {\n        instance.createLabel('seconds').mount(el.childNodes[2]);\n      }\n    }\n  }\n\n  function TwentyFourHourClock$1(el, instance) {\n    instance.createDivider().mount(el, el.childNodes[1]);\n\n    if (instance.face.showSeconds) {\n      instance.createDivider().mount(el, el.childNodes[3]);\n    }\n\n    if (instance.face.showLabels) {\n      instance.createLabel('hours').mount(el.childNodes[0]);\n      instance.createLabel('minutes').mount(el.childNodes[2]);\n\n      if (instance.face.showSeconds) {\n        instance.createLabel('seconds').mount(el.childNodes[4]);\n      }\n    }\n  }\n\n  function TwelveHourClock$1(el, instance) {\n    TwentyFourHourClock$1(el, instance);\n\n    if (instance.face.showMeridium && instance.face.meridium) {\n      var label = instance.createLabel(instance.face.meridium);\n      var parent = el.childNodes[el.childNodes.length - 1];\n      label.mount(parent).classList.add('flip-clock-meridium');\n    }\n  }\n\n  function WeekCounter$1(el, instance) {\n    instance.createDivider().mount(el, el.childNodes[1]);\n    instance.createDivider().mount(el, el.childNodes[3]);\n    instance.createDivider().mount(el, el.childNodes[5]);\n\n    if (instance.face.showSeconds) {\n      instance.createDivider().mount(el, el.childNodes[7]);\n    }\n\n    if (instance.face.showLabels) {\n      instance.createLabel('weeks').mount(el.childNodes[0]);\n      instance.createLabel('days').mount(el.childNodes[2]);\n      instance.createLabel('hours').mount(el.childNodes[4]);\n      instance.createLabel('minutes').mount(el.childNodes[6]);\n\n      if (instance.face.showSeconds) {\n        instance.createLabel('seconds').mount(el.childNodes[8]);\n      }\n    }\n  }\n\n  function YearCounter$1(el, instance) {\n    instance.createDivider().mount(el, el.childNodes[1]);\n    instance.createDivider().mount(el, el.childNodes[3]);\n    instance.createDivider().mount(el, el.childNodes[5]);\n    instance.createDivider().mount(el, el.childNodes[7]);\n\n    if (instance.face.showSeconds) {\n      instance.createDivider().mount(el, el.childNodes[9]);\n    }\n\n    if (instance.face.showLabels) {\n      instance.createLabel('years').mount(el.childNodes[0]);\n      instance.createLabel('weeks').mount(el.childNodes[2]);\n      instance.createLabel('days').mount(el.childNodes[4]);\n      instance.createLabel('hours').mount(el.childNodes[6]);\n      instance.createLabel('minutes').mount(el.childNodes[8]);\n\n      if (instance.face.showSeconds) {\n        instance.createLabel('seconds').mount(el.childNodes[10]);\n      }\n    }\n  }\n\n  var faces =\n  /*#__PURE__*/\n  Object.freeze({\n    DayCounter: DayCounter$1,\n    HourCounter: HourCounter$1,\n    MinuteCounter: MinuteCounter$1,\n    TwelveHourClock: TwelveHourClock$1,\n    TwentyFourHourClock: TwentyFourHourClock$1,\n    WeekCounter: WeekCounter$1,\n    YearCounter: YearCounter$1\n  });\n  var Original = {\n    Divider: Divider$1,\n    FlipClock: FlipClock,\n    Group: Group$1,\n    Label: Label$1,\n    List: List$1,\n    ListItem: ListItem$1,\n    faces: faces\n  };\n  /**\n   * @alias DefaultValues\n   * @type {object}\n   * @memberof module:Config/DefaultValues\n   */\n\n  var DefaultValues = {\n    face: Counter,\n    theme: Original,\n    language: English\n  };\n\n  var FlipClock$1 =\n  /*#__PURE__*/\n  function (_DomComponent) {\n    _inherits(FlipClock, _DomComponent);\n    /**\n     * Create a new `FlipClock` instance.\n     *\n     * @class FlipClock\n     * @extends DomComponent\n     * @param {HTMLElement} el - The HTML element used to bind clock DOM node.\n     * @param {*} value - The value that is passed to the clock face.\n     * @param {object|undefined} attributes - {@link FlipClock.Options} passed an object with key/value.\n     */\n\n    /**\n     * @namespace FlipClock.Options\n     * @classdesc An object of key/value pairs that will be used to set the attributes.\n     * \n     * ##### Example:\n     * \n     *     {\n     *        face: 'DayCounter',\n     *        language: 'es',\n     *        timer: Timer.make(500)\n     *     }\n     * \n     * @property {string|Face} [face={@link Faces.DayCounter}] - The clock's {@link Face} instance.\n     * @property {number} [interval=1000] - The clock's interval rate (in milliseconds).\n     * @property {object} [theme={@link Themes.Original}] - The clock's theme.\n     * @property {string|object} [language={@link Languages.English}] - The clock's language.\n     * @property {Timer} [timer={@link Timer}] - The clock's timer.\n     */\n\n\n    function FlipClock(el, value, attributes) {\n      var _this;\n\n      _classCallCheck(this, FlipClock);\n\n      if (!validate(el, HTMLElement)) {\n        error(ConsoleMessages.element);\n      }\n\n      if (isObject(value) && !attributes) {\n        attributes = value;\n        value = undefined;\n      }\n\n      var face = attributes.face || DefaultValues.face;\n      delete attributes.face;\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(FlipClock).call(this, Object.assign({\n        originalValue: value,\n        theme: DefaultValues.theme,\n        language: DefaultValues.language,\n        timer: Timer.make(attributes.interval || 1000)\n      }, attributes)));\n\n      if (!_this.face) {\n        _this.face = face;\n      }\n\n      _this.mount(el);\n\n      return _this;\n    }\n    /**\n     * The clock `Face`.\n     *\n     * @type {Face}\n     */\n\n\n    _createClass(FlipClock, [{\n      key: \"mount\",\n\n      /**\n       * Mount the clock to the parent DOM element.\n       *\n       * @param  {HTMLElement} el - The parent `HTMLElement`.\n       * @return {FlipClock} - The `FlipClock` instance.\n       */\n      value: function mount(el) {\n        _get(_getPrototypeOf(FlipClock.prototype), \"mount\", this).call(this, el);\n\n        this.face.mounted(this);\n        return this;\n      }\n      /**\n       * Render the clock's DOM nodes.\n       *\n       * @return {HTMLElement} - The parent `HTMLElement`.\n       */\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        // Call the parent render function\n        _get(_getPrototypeOf(FlipClock.prototype), \"render\", this).call(this); // Check to see if the face has a render function defined in the theme.\n        // This allows a face to completely re-render or add to the theme.\n        // This allows face specific interfaces for a theme.\n\n\n        if (this.theme.faces[this.face.name]) {\n          this.theme.faces[this.face.name](this.el, this);\n        } // Pass the clock instance to the rendered() function on the face.\n        // This allows global modifications to the rendered templates not\n        // theme specific.\n\n\n        this.face.rendered(this); // Return the rendered `HTMLElement`.\n\n        return this.el;\n      }\n      /**\n       * Start the clock.\n       *\n       * @param  {Function} fn - The interval callback.\n       * @return {FlipClock} - The `FlipClock` instance.\n       */\n\n    }, {\n      key: \"start\",\n      value: function start(fn) {\n        var _this2 = this;\n\n        if (!this.timer.started) {\n          this.value = this.originalValue;\n        }\n\n        isUndefined(this.face.stopAt) && (this.face.stopAt = this.stopAt);\n        isUndefined(this.face.originalValue) && (this.face.originalValue = this.originalValue);\n        this.timer.start(function () {\n          _this2.face.interval(_this2, fn);\n        });\n        this.face.started(this);\n        return this.emit('start');\n      }\n      /**\n       * Stop the clock.\n       *\n       * @param  {Function} fn - The stop callback.\n       * @return {FlipClock} - The `FlipClock` instance.\n       */\n\n    }, {\n      key: \"stop\",\n      value: function stop(fn) {\n        this.timer.stop(fn);\n        this.face.stopped(this);\n        return this.emit('stop');\n      }\n      /**\n       * Reset the clock to the original value.\n       *\n       * @param  {Function} fn - The interval callback.\n       * @return {FlipClock} - The `FlipClock` instance.\n       */\n\n    }, {\n      key: \"reset\",\n      value: function reset(fn) {\n        var _this3 = this;\n\n        this.value = this.originalValue;\n        this.timer.reset(function () {\n          return _this3.interval(_this3, fn);\n        });\n        this.face.reset(this);\n        return this.emit('reset');\n      }\n      /**\n       * Helper method to increment the clock's value.\n       *\n       * @param  {*|undefined} value - Increment the clock by the specified value.\n       *     If no value is passed, then the default increment is determined by\n       *     the Face, which is usually `1`.\n       * @return {FlipClock} - The `FlipClock` instance.\n       */\n\n    }, {\n      key: \"increment\",\n      value: function increment(value) {\n        this.face.increment(this, value);\n        return this;\n      }\n      /**\n       * Helper method to decrement the clock's value.\n       *\n       * @param  {*|undefined} value - Decrement the clock by the specified value.\n       *     If no value is passed, then the default decrement is determined by\n       *     the `Face`, which is usually `1`.\n       * @return {FlipClock} - The `FlipClock` instance.\n       */\n\n    }, {\n      key: \"decrement\",\n      value: function decrement(value) {\n        this.face.decrement(this, value);\n        return this;\n      }\n      /**\n       * Helper method to instantiate a new `Divider`.\n       *\n       * @param  {object|undefined} [attributes] - The attributes passed to the\n       *     `Divider` instance.\n       * @return {Divider} - The instantiated Divider.\n       */\n\n    }, {\n      key: \"createDivider\",\n      value: function createDivider(attributes) {\n        return Divider.make(Object.assign({\n          theme: this.theme,\n          language: this.language\n        }, attributes));\n      }\n      /**\n       * Helper method to instantiate a new `List`.\n       *\n       * @param  {*} value - The `List` value.\n       * @param  {object|undefined} [attributes] - The attributes passed to the\n       *     `List` instance.\n       * @return {List} - The instantiated `List`.\n       */\n\n    }, {\n      key: \"createList\",\n      value: function createList(value, attributes) {\n        return List.make(value, Object.assign({\n          theme: this.theme,\n          language: this.language\n        }, attributes));\n      }\n      /**\n       * Helper method to instantiate a new `Label`.\n       *\n       * @param  {*} value - The `Label` value.\n       * @param  {object|undefined} [attributes] - The attributes passed to the\n       *     `Label` instance.\n       * @return {Label} - The instantiated `Label`.\n       */\n\n    }, {\n      key: \"createLabel\",\n      value: function createLabel(value, attributes) {\n        return Label.make(value, Object.assign({\n          theme: this.theme,\n          language: this.language\n        }, attributes));\n      }\n      /**\n       * Helper method to instantiate a new `Group`.\n       *\n       * @param  {array} items - An array of `List` items to group.\n       * @param  {Group|undefined} [attributes] - The attributes passed to the\n       *     `Group` instance.\n       * @return {Group} - The instantiated `Group`.\n       */\n\n    }, {\n      key: \"createGroup\",\n      value: function createGroup(items, attributes) {\n        return Group.make(items, Object.assign({\n          theme: this.theme,\n          language: this.language\n        }, attributes));\n      }\n      /**\n       * The `defaults` attribute.\n       *\n       * @type {object}\n       */\n\n    }, {\n      key: \"face\",\n      get: function get$$1() {\n        return this.$face;\n      },\n      set: function set(value) {\n        if (!validate(value, [Face, 'string', 'function'])) {\n          error(ConsoleMessages.face);\n        }\n\n        this.$face = (Faces[value] || value).make(Object.assign(this.getPublicAttributes(), {\n          originalValue: this.face ? this.face.originalValue : undefined\n        }));\n        this.$face.initialized(this);\n\n        if (this.value) {\n          this.$face.value = this.face.createFaceValue(this, this.value.value);\n        } else if (!this.value) {\n          this.value = this.originalValue;\n        }\n\n        this.el && this.render();\n      }\n      /**\n       * The `stopAt` attribute.\n       *\n       * @type {*}\n       */\n\n    }, {\n      key: \"stopAt\",\n      get: function get$$1() {\n        return isFunction(this.$stopAt) ? this.$stopAt(this) : this.$stopAt;\n      },\n      set: function set(value) {\n        this.$stopAt = value;\n      }\n      /**\n       * The `timer` instance.\n       *\n       * @type {Timer}\n       */\n\n    }, {\n      key: \"timer\",\n      get: function get$$1() {\n        return this.$timer;\n      },\n      set: function set(timer) {\n        if (!validate(timer, Timer)) {\n          error(ConsoleMessages.timer);\n        }\n\n        this.$timer = timer;\n      }\n      /**\n       * Helper method to The clock's `FaceValue` instance.\n       *\n       * @type {FaceValue|null}\n       */\n\n    }, {\n      key: \"value\",\n      get: function get$$1() {\n        return this.face ? this.face.value : null;\n      },\n      set: function set(value) {\n        if (!this.face) {\n          throw new Error('A face must be set before setting a value.');\n        }\n\n        if (value instanceof FaceValue) {\n          this.face.value = value;\n        } else if (this.value) {\n          this.face.value = this.face.value.clone(value);\n        } else {\n          this.face.value = this.face.createFaceValue(this, value);\n        }\n\n        this.el && this.render();\n      }\n      /**\n       * The `originalValue` attribute.\n       *\n       * @type {*}\n       */\n\n    }, {\n      key: \"originalValue\",\n      get: function get$$1() {\n        if (isFunction(this.$originalValue) && !this.$originalValue.name) {\n          return this.$originalValue();\n        }\n\n        if (!isUndefined(this.$originalValue) && !isNull(this.$originalValue)) {\n          return this.$originalValue;\n        }\n\n        return this.face ? this.face.defaultValue() : undefined;\n      },\n      set: function set(value) {\n        this.$originalValue = value;\n      }\n    }], [{\n      key: \"defineName\",\n\n      /**\n       * Define the name of the class.\n       *\n       * @return {string}\n       */\n      value: function defineName() {\n        return 'FlipClock';\n      }\n      /**\n       * Helper method to set the default `Face` value.\n       *\n       * @param  {Face} value - The default `Face` class.This should be a\n       *     constructor.\n       * @return {void}\n       */\n\n    }, {\n      key: \"setDefaultFace\",\n      value: function setDefaultFace(value) {\n        if (!validate(value, Face)) {\n          error(ConsoleMessages.face);\n        }\n\n        DefaultValues.face = value;\n      }\n      /**\n       * Helper method to set the default theme.\n       *\n       * @param {object} value - The default theme.\n       * @return {void}\n       */\n\n    }, {\n      key: \"setDefaultTheme\",\n      value: function setDefaultTheme(value) {\n        if (!validate(value, 'object')) {\n          error(ConsoleMessages.theme);\n        }\n\n        DefaultValues.theme = value;\n      }\n      /**\n       * Helper method to set the default language.\n       *\n       * @param {object} value - The default language.\n       * @return {void}\n       */\n\n    }, {\n      key: \"setDefaultLanguage\",\n      value: function setDefaultLanguage(value) {\n        if (!validate(value, 'object')) {\n          error(ConsoleMessages.language);\n        }\n\n        DefaultValues.language = value;\n      }\n    }, {\n      key: \"defaults\",\n      get: function get$$1() {\n        return DefaultValues;\n      }\n    }]);\n\n    return FlipClock;\n  }(DomComponent);\n\n  return FlipClock$1;\n});","map":null,"metadata":{},"sourceType":"script"}